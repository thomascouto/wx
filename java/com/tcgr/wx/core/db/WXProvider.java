package com.tcgr.wx.core.db;import android.content.ContentProvider;import android.content.ContentUris;import android.content.ContentValues;import android.content.UriMatcher;import android.database.Cursor;import android.database.sqlite.SQLiteQueryBuilder;import android.net.Uri;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import com.tcgr.wx.core.Util;import com.tcgr.wx.core.interfaces.Constants;import java.util.HashMap;/** * Content Provider da Aplicação. Se comunicará com o banco de dados SQLite. * * Created by thomas on 18/03/16. */@SuppressWarnings("ConstantConditions")public class WXProvider extends ContentProvider {    private static final int METAR_TRIGGER = 1;    private static final int TAF_TRIGGER = 2;    private static final int ROTAER = 3;    private static final int NOTAM = 4;    private static final UriMatcher uriMatcher;    static {        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);        uriMatcher.addURI(Constants.PROVIDER_NAME, DbSchema.MetarSearchTable.NAME, METAR_TRIGGER);        uriMatcher.addURI(Constants.PROVIDER_NAME, DbSchema.TafSearchTable.NAME, TAF_TRIGGER);        uriMatcher.addURI(Constants.PROVIDER_NAME, DbSchema.RotaerTable.NAME, ROTAER);        uriMatcher.addURI(Constants.PROVIDER_NAME, DbSchema.NotamTable.NAME, NOTAM);    }    /**     * Projection Map.     *     * ******* !!! ATENÇÃO !!! *******     * ******* !!! ATENÇÃO !!! *******     *     * Está ok, porque todas as tabelas que usam possuem     * o mesmo nome de colunas. Em caso de mudança, modificar o Map.     */    private static HashMap<String, String> map = new HashMap<>();    static {        map.put("content", "content");        map.put("icao", "icao");    }    @Override    public boolean onCreate() {        return false;    }    @Nullable @Override    public Cursor query(@NonNull Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {        SQLiteQueryBuilder sqLiteQueryBuilder = new SQLiteQueryBuilder();        switch (uriMatcher.match(uri)) {            case METAR_TRIGGER:                sqLiteQueryBuilder.setTables(DbSchema.MetarSearchTable.NAME);                break;            case TAF_TRIGGER:                sqLiteQueryBuilder.setTables(DbSchema.TafSearchTable.NAME);                break;            case ROTAER:                sqLiteQueryBuilder.setTables(DbSchema.RotaerTable.NAME);                break;            case NOTAM:                sqLiteQueryBuilder.setTables(DbSchema.NotamTable.NAME);                break;            default:                throw new IllegalArgumentException("Unknown URI " + uri);        }        sqLiteQueryBuilder.setProjectionMap(map);        Cursor cursor = sqLiteQueryBuilder.query(DatabaseManager.getInstance().openDatabase(),                projection,                selection,                selectionArgs,                null,                null,                sortOrder);        cursor.setNotificationUri(getContext().getContentResolver(), uri);        return cursor;    }    @Nullable @Override    public String getType(@NonNull Uri uri) {        return null;    }    @Nullable @Override    public Uri insert(@NonNull Uri uri, ContentValues values) {        long row;        Uri newUri;        switch (uriMatcher.match(uri)) {            case METAR_TRIGGER:                row = DatabaseManager.getInstance().openDatabase().replace(DbSchema.MetarSearchTable.NAME, null, values);                newUri = ContentUris.withAppendedId(DbSchema.MetarSearchTable.CONTENT_URI, row);                break;            case TAF_TRIGGER:                row = DatabaseManager.getInstance().openDatabase().replace(DbSchema.TafSearchTable.NAME, null, values);                newUri = ContentUris.withAppendedId(DbSchema.TafSearchTable.CONTENT_URI, row);                break;            case ROTAER:                row = DatabaseManager.getInstance().openDatabase().insertOrThrow(DbSchema.RotaerTable.NAME, null, values);                newUri = ContentUris.withAppendedId(DbSchema.RotaerTable.CONTENT_URI, row);                break;            case NOTAM:                row = DatabaseManager.getInstance().openDatabase().insertOrThrow(DbSchema.NotamTable.NAME, null, values);                newUri = ContentUris.withAppendedId(DbSchema.NotamTable.CONTENT_URI, row);                break;            default:                throw new IllegalArgumentException("Unsupported URI " + uri );        }        getContext().getContentResolver().notifyChange(newUri, null);        return newUri;    }    @Override    public int delete(@NonNull Uri uri, String selection, String[] selectionArgs) {        int count;        if(selection != null) {            selection = selection + " IN (" + Util.makePlaceHolder(selectionArgs.length) + ") ";        }        switch (uriMatcher.match(uri)) {            case NOTAM:                count = DatabaseManager.getInstance().openDatabase().delete(DbSchema.NotamTable.NAME, selection, selectionArgs);                break;            case ROTAER:                count = DatabaseManager.getInstance().openDatabase().delete(DbSchema.RotaerTable.NAME, selection, selectionArgs);                break;            case METAR_TRIGGER:                count = DatabaseManager.getInstance().openDatabase().delete(DbSchema.MetarSearchTable.NAME, null, null);                break;            case TAF_TRIGGER:                count = DatabaseManager.getInstance().openDatabase().delete(DbSchema.TafSearchTable.NAME, null, null);                break;            default:                throw new IllegalArgumentException("Unsupported URI " + uri );        }        return count;    }    @Override    public int update(@NonNull Uri uri, ContentValues values, String selection, String[] selectionArgs) {        int count;        switch (uriMatcher.match(uri)) {            case ROTAER:                count = DatabaseManager.getInstance().openDatabase().update(DbSchema.RotaerTable.NAME, values, selection, selectionArgs);                break;            case NOTAM:                count = DatabaseManager.getInstance().openDatabase().update(DbSchema.NotamTable.NAME, values, selection, selectionArgs);                break;            default:                throw new IllegalArgumentException("Unsupported URI " + uri );        }        getContext().getContentResolver().notifyChange(uri, null);        return count;    }}